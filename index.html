<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="vivid的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="vivid的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="vivid">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>vivid的博客</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">vivid的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">vivid</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/09/docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vivid">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vivid的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/09/docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">docker环境搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-05-09 18:05:49 / 修改时间：21:51:03" itemprop="dateCreated datePublished" datetime="2021-05-09T18:05:49+08:00">2021-05-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="配置docker-代理"><a href="#配置docker-代理" class="headerlink" title="配置docker 代理"></a>配置docker 代理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://ih6ib4yz.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将可执行权限应用于二进制文件：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建软链：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">测试是否安装成功：</span></span><br><span class="line"></span><br><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>​    </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 改变设置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使之立即生效</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建并改变该目录权限</span></span><br><span class="line"></span><br><span class="line">sysctl -w vm.max_map_count=262144</span><br><span class="line">sysctl -p</span><br><span class="line">mkdir /opt/elasticsearch/data/</span><br><span class="line">chmod 777 /opt/elasticsearch/data</span><br></pre></td></tr></table></figure>

<p>修改Logstash的配置文件logstash.conf中output节点下的Elasticsearch连接地址为es:9200。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;opt&#x2F;logstash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#logstash.conf文件内容</span></span><br><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode =&gt; <span class="string">&quot;server&quot;</span></span><br><span class="line">    host =&gt; <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    port =&gt; <span class="number">4560</span></span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">    type =&gt; <span class="string">&quot;debug&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode =&gt; <span class="string">&quot;server&quot;</span></span><br><span class="line">    host =&gt; <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    port =&gt; <span class="number">4561</span></span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">    type =&gt; <span class="string">&quot;error&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode =&gt; <span class="string">&quot;server&quot;</span></span><br><span class="line">    host =&gt; <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    port =&gt; <span class="number">4562</span></span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">    type =&gt; <span class="string">&quot;business&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    mode =&gt; <span class="string">&quot;server&quot;</span></span><br><span class="line">    host =&gt; <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    port =&gt; <span class="number">4563</span></span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">    type =&gt; <span class="string">&quot;record&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter&#123;</span><br><span class="line">  if [type] == <span class="string">&quot;record&quot;</span> &#123;</span><br><span class="line">    mutate &#123;</span><br><span class="line">      remove_field =&gt; <span class="string">&quot;port&quot;</span></span><br><span class="line">      remove_field =&gt; <span class="string">&quot;host&quot;</span></span><br><span class="line">      remove_field =&gt; <span class="string">&quot;@version&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    json &#123;</span><br><span class="line">      source =&gt; <span class="string">&quot;message&quot;</span></span><br><span class="line">      remove_field =&gt; [<span class="string">&quot;message&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; <span class="string">&quot;es:9200&quot;</span></span><br><span class="line">    index =&gt; <span class="string">&quot;mall-%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 docker-compose-env.yml 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  elasticsearch:</span><br><span class="line">    image: elasticsearch:<span class="number">7.6</span>.<span class="number">2</span></span><br><span class="line">    container_name: elasticsearch</span><br><span class="line">    environment:</span><br><span class="line">      - <span class="string">&quot;cluster.name=elasticsearch&quot;</span> <span class="comment">#设置集群名称为elasticsearch</span></span><br><span class="line">      - <span class="string">&quot;discovery.type=single-node&quot;</span> <span class="comment">#以单一节点模式启动</span></span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms256m -Xmx256m&quot;</span> <span class="comment">#设置使用jvm内存大小</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/elasticsearch/plugins:/usr/share/elasticsearch/plugins <span class="comment">#插件文件挂载</span></span><br><span class="line">      - /opt/elasticsearch/data:/usr/share/elasticsearch/data <span class="comment">#数据文件挂载</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">9200</span>:<span class="number">9200</span></span><br><span class="line">      - <span class="number">9300</span>:<span class="number">9300</span></span><br><span class="line">  logstash:</span><br><span class="line">    image: logstash:<span class="number">7.6</span>.<span class="number">2</span></span><br><span class="line">    container_name: logstash</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf <span class="comment">#挂载logstash的配置文件</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - elasticsearch <span class="comment">#kibana在elasticsearch启动之后再启动</span></span><br><span class="line">    links:</span><br><span class="line">      - elasticsearch:es <span class="comment">#可以用es这个域名访问elasticsearch服务</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">4560</span>:<span class="number">4560</span></span><br><span class="line">      - <span class="number">4561</span>:<span class="number">4561</span></span><br><span class="line">      - <span class="number">4562</span>:<span class="number">4562</span></span><br><span class="line">      - <span class="number">4563</span>:<span class="number">4563</span></span><br><span class="line">  kibana:</span><br><span class="line">    image: kibana:<span class="number">7.6</span>.<span class="number">2</span></span><br><span class="line">    container_name: kibana</span><br><span class="line">    links:</span><br><span class="line">      - elasticsearch:es <span class="comment">#可以用es这个域名访问elasticsearch服务</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - elasticsearch <span class="comment">#kibana在elasticsearch启动之后再启动</span></span><br><span class="line">    environment:</span><br><span class="line">      - <span class="string">&quot;elasticsearch.hosts=http://es:9200&quot;</span> <span class="comment">#设置访问elasticsearch的地址</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">5601</span>:<span class="number">5601</span></span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose-<span class="keyword">env</span>.yml up -d</span><br></pre></td></tr></table></figure>

<h2 id="elasticsearch需要安装中文分词器IKAnalyzer，并重新启动。"><a href="#elasticsearch需要安装中文分词器IKAnalyzer，并重新启动。" class="headerlink" title="elasticsearch需要安装中文分词器IKAnalyzer，并重新启动。"></a>elasticsearch需要安装中文分词器IKAnalyzer，并重新启动。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">此命令需要在容器中运行</span></span><br><span class="line">elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.2/elasticsearch-analysis-ik-7.6.2.zip</span><br><span class="line">docker restart elasticsearch</span><br><span class="line"><span class="meta">#</span><span class="bash">elasticsearch-sql</span></span><br><span class="line">elasticsearch-plugin install https://github.com/NLPchina/elasticsearch-sql/releases/download/7.6.2.0/elasticsearch-sql-7.6.2.0.zip</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="logstash-需要安装json-lines插件，并重新启动"><a href="#logstash-需要安装json-lines插件，并重新启动" class="headerlink" title="logstash 需要安装json_lines插件，并重新启动"></a>logstash 需要安装<code>json_lines</code>插件，并重新启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it logstash /bin/bash</span><br><span class="line">logstash-plugin install logstash-codec-json_lines</span><br><span class="line">docker restart logstash</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/07/Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vivid">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vivid的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/07/Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/" class="post-title-link" itemprop="url">Explain执行计划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-05-07 22:05:40 / 修改时间：22:21:53" itemprop="dateCreated datePublished" datetime="2021-05-07T22:05:40+08:00">2021-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="Explain有哪些信息"><a href="#Explain有哪些信息" class="headerlink" title="Explain有哪些信息"></a>Explain有哪些信息</h2><p><code>Explain</code> 执行计划包含字段信息如下：分别是 <code>id</code>、<code>select_type</code>、<code>table</code>、<code>partitions</code>、<code>type</code>、<code>possible_keys</code>、<code>key</code>、<code>key_len</code>、<code>ref</code>、<code>rows</code>、<code>filtered</code>、<code>Extra</code> 12个字段。 <img src="https://user-gold-cdn.xitu.io/2020/5/20/172311d20c534c4b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"> 下边我们会结合具体的<code>SQL</code>示例，详细的解读每个字段以及每个字段中不同参数的含义，以下所有示例数据库版本为 <code>MySQL.5.7.17</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select version() from dual;</span><br><span class="line">+------------+</span><br><span class="line">| version()  |</span><br><span class="line">+------------+</span><br><span class="line">| 5.7.17-log |</span><br><span class="line">+------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们创建三张表 <code>one</code>、<code>two</code>、<code>three</code>，表之间的关系 <code>one.two_id = two.two_id AND two.three_id = three.three_id</code>。</p>
<h2 id="Explain执行计划详解"><a href="#Explain执行计划详解" class="headerlink" title="Explain执行计划详解"></a>Explain执行计划详解</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p><code>id：</code> ：表示查询中执行select子句或者操作表的顺序，**<code>id</code>的值越大，代表优先级越高，越先执行**。 <code>id</code>大致会出现 3种情况：</p>
<h5 id="id相同"><a href="#id相同" class="headerlink" title="id相同"></a><code>id</code>相同</h5><p>看到三条记录的<code>id</code>都相同，可以理解成这三个表为一组，具有同样的优先级，执行顺序由上而下，具体顺序由优化器决定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM one o,two t, three r WHERE o.two_id &#x3D; t.two_id AND t.three_id &#x3D; r.three_id;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                  | rows | filtered | Extra                                              |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL                 |    2 |      100 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL                 |    2 |       50 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">|  1 | SIMPLE      | r     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xin-slave.t.three_id |    1 |      100 | NULL                                               |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h5 id="id不同"><a href="#id不同" class="headerlink" title="id不同"></a><code>id</code>不同</h5><p>如果我们的 <code>SQL</code> 中存在子查询，那么 <code>id</code>的序号会递增，<code>id</code>值越大优先级越高，越先被执行 。当三个表依次嵌套，发现最里层的子查询 <code>id</code>最大，最先执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select * from one o where o.two_id &#x3D; (select t.two_id from two t where t.three_id &#x3D; (select r.three_id  from three r where r.three_name&#x3D;&#39;我是第三表2&#39;));</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | o     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |</span><br><span class="line">|  2 | SUBQUERY    | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |</span><br><span class="line">|  3 | SUBQUERY    | r     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">my</span><br></pre></td></tr></table></figure>

<h5 id="以上两种同时存在"><a href="#以上两种同时存在" class="headerlink" title="以上两种同时存在"></a>以上两种同时存在</h5><p>将上边的 <code>SQL</code> 稍微修改一下，增加一个子查询，发现 <code>id</code>的以上两种同时存在。相同<code>id</code>划分为一组，这样就有三个组，同组的从上往下顺序执行，不同组 <code>id</code>值越大，优先级越高，越先执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  EXPLAIN select * from one o where o.two_id &#x3D; (select t.two_id from two t where t.three_id &#x3D; (select r.three_id  from three r where r.three_name&#x3D;&#39;我是第三表2&#39;)) AND o.one_id in(select one_id from one where o.one_name&#x3D;&quot;我是第一表2&quot;);</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | o     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL               |    2 |       50 | Using where |</span><br><span class="line">|  1 | PRIMARY     | one   | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xin-slave.o.one_id |    1 |      100 | Using index |</span><br><span class="line">|  2 | SUBQUERY    | t     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL               |    2 |       50 | Using where |</span><br><span class="line">|  3 | SUBQUERY    | r     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL               |    2 |       50 | Using where |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><code>select_type</code>：表示 <code>select</code> 查询的类型，主要是用于区分各种复杂的查询，例如：<code>普通查询</code>、<code>联合查询</code>、<code>子查询</code>等。</p>
<h5 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h5><p><code>SIMPLE</code>：表示最简单的 select 查询语句，也就是在查询中不包含子查询或者 <code>union</code>交并差集等操作。</p>
<h5 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h5><p><code>PRIMARY</code>：当查询语句中包含任何复杂的子部分，最外层查询则被标记为<code>PRIMARY</code>。</p>
<h5 id="SUBQUERY"><a href="#SUBQUERY" class="headerlink" title="SUBQUERY"></a>SUBQUERY</h5><p><code>SUBQUERY</code>：当 <code>select</code> 或 <code>where</code> 列表中包含了子查询，该子查询被标记为：<code>SUBQUERY</code> 。</p>
<h5 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a>DERIVED</h5><p><code>DERIVED</code>：表示包含在<code>from</code>子句中的子查询的select，在我们的 <code>from</code> 列表中包含的子查询会被标记为<code>derived</code> 。</p>
<h5 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h5><p><code>UNION</code>：如果<code>union</code>后边又出现的<code>select</code> 语句，则会被标记为<code>union</code>；若 <code>union</code> 包含在 <code>from</code> 子句的子查询中，外层 <code>select</code> 将被标记为 <code>derived</code>。</p>
<h5 id="UNION-RESULT"><a href="#UNION-RESULT" class="headerlink" title="UNION RESULT"></a>UNION RESULT</h5><p><code>UNION RESULT</code>：代表从<code>union</code>的临时表中读取数据，而<code>table</code>列的``表示用第一个和第四个<code>select</code>的结果进行<code>union</code>操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select t.two_name, ( select one.one_id from one) o from (select two_id,two_name from two where two_name &#x3D;&#39;&#39;) t  union (select r.three_name,r.three_id from three r);</span><br><span class="line"></span><br><span class="line">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">| id   | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">|    1 | PRIMARY      | two        | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |    2 |       50 | Using where     |</span><br><span class="line">|    2 | SUBQUERY     | one        | NULL       | index | NULL          | PRIMARY | 4       | NULL |    2 |      100 | Using index     |</span><br><span class="line">|    4 | UNION        | r          | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |    2 |      100 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,4&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL | NULL     | Using temporary |</span><br><span class="line">+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表，例如上边的<code>DERIVED</code>、 ``等。</p>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>查询时匹配到的分区信息，对于非分区表值为<code>NULL</code>，当查询的是分区表时，<code>partitions</code>显示分区表命中的分区情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table          | partitions                      | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one            | p201801,p201802,p201803,p300012 | index | NULL          | PRIMARY | 9       | NULL |    3 |      100 | Using index |</span><br><span class="line">+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type&#96;：查询使用了何种类型，它在 &#96;SQL&#96;优化中是一个非常重要的指标，以下性能从好到坏依次是：&#96;system&#96;  &gt; &#96;const&#96; &gt; &#96;eq_ref&#96; &gt; &#96;ref&#96;  &gt; &#96;ref_or_null&#96; &gt; &#96;index_merge&#96; &gt; &#96;unique_subquery&#96; &gt; &#96;index_subquery&#96; &gt; &#96;range&#96; &gt; &#96;index&#96; &gt; &#96;ALL</span><br></pre></td></tr></table></figure>

<h5 id="system"><a href="#system" class="headerlink" title="system"></a>system</h5><p><code>system</code>： 当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快。</p>
<h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><p><code>const</code>：表示查询时命中 <code>primary key</code> 主键或者 <code>unique</code> 唯一索引，或者被连接的部分是一个常量(<code>const</code>)值。这类扫描效率极高，返回数据量少，速度非常快。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three where three_id&#x3D;1;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h5><p><code>eq_ref</code>：查询时命中主键<code>primary key</code> 或者 <code>unique key</code>索引， <code>type</code> 就是 <code>eq_ref</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select o.one_name from one o ,two t where o.one_id &#x3D; t.two_id ; </span><br><span class="line">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref                | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | index  | PRIMARY       | idx_name | 768     | NULL               |    2 |      100 | Using index |</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | eq_ref | PRIMARY       | PRIMARY  | 4       | xin-slave.o.one_id |    1 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p><code>ref</code>：区别于<code>eq_ref</code> ，<code>ref</code>表示使用非唯一性索引，会找到很多个符合条件的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select o.one_id from one o where o.one_name &#x3D; &quot;xin&quot; ; </span><br><span class="line">+--------+</span><br><span class="line">| one_id |</span><br><span class="line">+--------+</span><br><span class="line">|      1 |</span><br><span class="line">|      3 |</span><br><span class="line">+--------+&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">sql</span><br><span class="line">mysql&gt; EXPLAIN select o.one_id from one o where o.one_name &#x3D; &quot;xin&quot; ; </span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ref  | idx_name      | idx_name | 768     | const |    1 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h5><p><code>ref_or_null</code>：这种连接类型类似于 ref，区别在于 <code>MySQL</code>会额外搜索包含<code>NULL</code>值的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select o.one_id from one o where o.one_name &#x3D; &quot;xin&quot; OR o.one_name IS NULL; </span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ref_or_null | idx_name      | idx_name | 768     | const |    3 |      100 | Using where; Using index |</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h5><p><code>index_merge</code>：使用了索引合并优化方法，查询使用了两个以上的索引。</p>
<p>下边示例中同时使用到主键<code>one_id</code> 和 字段<code>one_name</code>的<code>idx_name</code> 索引 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select * from one o where o.one_id &gt;1 and o.one_name &#x3D;&#39;xin&#39;; </span><br><span class="line">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                                          |</span><br><span class="line">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | index_merge | PRIMARY,idx_name | idx_name,PRIMARY | 772,4   | NULL |    1 |      100 | Using intersect(idx_name,PRIMARY); Using where |</span><br><span class="line">+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h5><p><code>unique_subquery</code>：替换下面的 <code>IN</code>子查询，子查询返回不重复的集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value IN (SELECT primary_key FROM single_table WHERE some_expr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h5><p><code>index_subquery</code>：区别于<code>unique_subquery</code>，用于非唯一索引，可以返回重复值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value IN (SELECT key_column FROM single_table WHERE some_expr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5><p><code>range</code>：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在<code>where</code>语句中使用 <code>bettween...and</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>in</code> 等条件查询 <code>type</code> 都是 <code>range</code>。</p>
<p>举个栗子：<code>three</code>表中<code>three_id</code>为唯一主键，<code>user_id</code>普通字段未建索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three where three_id BETWEEN 2 AND 3;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    1 |      100 | Using where |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从结果中看到只有对设置了索引的字段，做范围检索 <code>type</code> 才是 <code>range</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three where user_id BETWEEN 2 AND 3;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p><code>index</code>：<code>Index</code> 与<code>ALL</code> 其实都是读全表，区别在于<code>index</code>是遍历索引树读取，而<code>ALL</code>是从硬盘中读取。</p>
<p>下边示例：<code>three_id</code> 为主键，不带 <code>where</code> 条件全表查询 ，<code>type</code>结果为<code>index</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT three_id from three ;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | index | NULL          | PRIMARY | 4       | NULL |    1 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h5><p><code>ALL</code>：将遍历全表以找到匹配的行，性能最差。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from two ;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | two   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code>：表示在<code>MySQL</code>中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，<strong>但这个索引并不定一会是最终查询数据时所被用到的索引</strong>。具体请参考上边的例子。</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p><code>key</code>：区别于<code>possible_keys</code>，key是查询中实际使用到的索引，若没有使用索引，显示为<code>NULL</code>。具体请参考上边的例子。</p>
<blockquote>
<p>当 <code>type</code> 为 <code>index_merge</code> 时，可能会显示多个索引。</p>
</blockquote>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p><code>key_len</code>：表示查询用到的索引长度（字节数），原则上长度越短越好 。</p>
<ul>
<li>单列索引，那么需要将整个索引长度算进去；</li>
<li>多列索引，不是所有列都能用到，需要计算查询中实际用到的列。</li>
</ul>
<blockquote>
<p>注意：<code>key_len</code>只计算<code>where</code>条件中用到的索引长度，而排序和分组即便是用到了索引，也不会计算到<code>key_len</code>中。</p>
</blockquote>
<h3 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h3><p><code>ref</code>：常见的有：<code>const</code>，<code>func</code>，<code>null</code>，字段名。</p>
<ul>
<li>当使用常量等值查询，显示<code>const</code>，</li>
<li>当关联查询时，会显示相应关联表的<code>关联字段</code></li>
<li>如果查询条件使用了<code>表达式</code>、<code>函数</code>，或者条件列发生内部隐式转换，可能显示为<code>func</code></li>
<li>其他情况<code>null</code></li>
</ul>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p><code>rows</code>：以表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数。</p>
<p>这是评估<code>SQL</code> 性能的一个比较重要的数据，<code>mysql</code>需要扫描的行数，很直观的显示 <code>SQL</code> 性能的好坏，一般情况下 <code>rows</code> 值越小越好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from three;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | three | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p><code>filtered</code> 这个是一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。</p>
<p>在<code>MySQL.5.7</code>版本以前想要显示<code>filtered</code>需要使用<code>explain extended</code>命令。<code>MySQL.5.7</code>后，默认<code>explain</code>直接显示<code>partitions</code>和<code>filtered</code>的信息。</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p><code>Extra</code> ：不适合在其他列中显示的信息，<code>Explain</code> 中的很多额外的信息会在 <code>Extra</code> 字段显示。</p>
<h5 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h5><p><code>Using index</code>：我们在相应的 <code>select</code> 操作中使用了覆盖索引，通俗一点讲就是查询的列被索引覆盖，使用到覆盖索引查询速度会非常快，<code>SQl</code>优化中理想的状态。</p>
<p>什么又是覆盖索引?</p>
<p>一条 <code>SQL</code>只需要通过索引就可以返回，我们所需要查询的数据（一个或几个字段），而不必通过二级索引，查到主键之后再通过主键查询整行数据（<code>select *</code> ）。</p>
<p><code>one_id</code>表为主键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_id from one ;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | index | NULL          | idx_two_id | 5       | NULL |    3 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：想要使用到覆盖索引，我们在 <code>select</code> 时只取出需要的字段，不可<code>select *</code>，而且该字段建了索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * from one ;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h5><p><code>Using where</code>：查询时未找到可用的索引，进而通过<code>where</code>条件过滤获取所需数据，但要注意的是并不是所有带<code>where</code>语句的查询都会显示<code>Using where</code>。</p>
<p>下边示例<code>create_time</code> 并未用到索引，<code>type</code> 为 <code>ALL</code>，即<code>MySQL</code>通过全表扫描后再按<code>where</code>条件筛选数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one where create_time &#x3D;&#39;2020-05-18&#39;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="Using temporary"></a>Using temporary</h5><p><code>Using temporary</code>：表示查询后结果需要使用临时表来存储，一般在排序或者分组查询时用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one where one_id in (1,2) group by one_name;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | range| NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using temporary; Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h5><p><code>Using filesort</code>：表示无法利用索引完成的排序操作，也就是<code>ORDER BY</code>的字段没有索引，通常这样的SQL都是需要优化的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_id from one  ORDER BY create_time;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果<code>ORDER BY</code>字段有索引就会用到覆盖索引，相比执行速度快很多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_id from one  ORDER BY one_id;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | one   | NULL       | index | NULL          | PRIMARY | 4       | NULL |    3 |      100 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Using-join-buffer"><a href="#Using-join-buffer" class="headerlink" title="Using join buffer"></a>Using join buffer</h5><p><code>Using join buffer</code>：在我们联表查询的时候，如果表的连接条件没有用到索引，需要有一个连接缓冲区来存储中间结果。</p>
<p>先看一下有索引的情况：连接条件 <code>one_name</code> 、<code>two_name</code> 都用到索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one o,two t where o.one_name &#x3D; t.two_name;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref                  | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | index | idx_name      | idx_name | 768     | NULL                 |    3 |      100 | Using where; Using index |</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ref   | idx_name      | idx_name | 768     | xin-slave.o.one_name |    1 |      100 | Using index              |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来删掉 连接条件 <code>one_name</code> 、<code>two_name</code> 的字段索引。发现<code>Extra</code> 列变成 <code>Using join buffer</code>，<code>type</code>均为全表扫描，这也是<code>SQL</code>优化中需要注意的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one o,two t where o.one_name &#x3D; t.two_name;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |      100 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | o     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Impossible-where"><a href="#Impossible-where" class="headerlink" title="Impossible where"></a>Impossible where</h5><p><code>Impossible where</code>：表示在我们用不太正确的<code>where</code>语句，导致没有符合条件的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT one_name from one WHERE 1&#x3D;2;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | Impossible WHERE |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="No-tables-used"><a href="#No-tables-used" class="headerlink" title="No tables used"></a>No tables used</h5><p><code>No tables used</code>：我们的查询语句中没有<code>FROM</code>子句，或者有 <code>FROM DUAL</code>子句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select now();</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | No tables used |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+--------</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/28/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vivid">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vivid的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/28/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">面试总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-28 21:36:41 / 修改时间：23:22:07" itemprop="dateCreated datePublished" datetime="2021-04-28T21:36:41+08:00">2021-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<h2 id="java-cpu-满载怎么定位"><a href="#java-cpu-满载怎么定位" class="headerlink" title="java cpu 满载怎么定位"></a>java cpu 满载怎么定位</h2><p>top |grep java 或者 jps指令找到java进程的pid（6167）</p>
<p>top -H -p pid  以线程的形式查看该进程 top -H -p 6167</p>
<p><img src="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428214822.png" alt="image-20210428214818372"></p>
<p>前面的线程ID是10进制的，，需要转换成16进制，，因为等下在jstack命令取出来的线程ID是16进制的：这里就随便选一个线程ID 去转换了，真实环境肯定是选择CPU占用率最高的那个线程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;obase=16;6219&quot; | bc</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428215138.png" alt="image-20210428215134492"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 6167 &gt;threadInfo.txt</span><br></pre></td></tr></table></figure>

<p> 信息输出到文件 然后查看。也可以直接在命令里面查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428215709.png" alt="img"></p>
<h2 id="微服务序列化方式"><a href="#微服务序列化方式" class="headerlink" title="微服务序列化方式"></a>微服务序列化方式</h2><p>Dubbo 支持多种序列化方式：JDK自带的序列化、hessian2、JSON、Kryo、FST、Protostuff，ProtoBuf等等。</p>
<p>Dubbo 默认使用的序列化方式是 hession2。</p>
<p>一般我们不会直接使用 JDK 自带的序列化方式。主要原因有两个：</p>
<ol>
<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
</ol>
<p>JSON 序列化由于性能问题，我们一般也不会考虑使用。</p>
<p>像 Protostuff，ProtoBuf、hessian2这些都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p>
<p>Kryo和FST这两种序列化方式是 Dubbo 后来才引入的，性能非常好。不过，这两者都是专门针对 Java 语言的。Dubbo 官网的一篇文章中提到说</p>
<h2 id="zk实现分布式共享锁"><a href="#zk实现分布式共享锁" class="headerlink" title="zk实现分布式共享锁"></a>zk实现分布式共享锁</h2><p>第一种<br>步骤：</p>
<p>需要访问某共享资源的节点进程，往Zookeeper的同一父节点（比如/locks）下去创建一个临时有序节点。<br>每个进程获取该父节点下的子节点列表，并且获取一个最小的子节点的路径，与当前自己创建的临时有序节点是否是同一节点，是的话就获取锁，不是的话就获取锁失败。<br>获取锁失败后，需要监听比它小的上一个节点的删除事件，并阻塞进程。一旦被监听的节点被删除了，触发了节点删除事件，在回调中就可以唤醒该进程进行获得锁。<br>主要就这三步，就可以使用Zookeeper实现一个分布式排它锁。<br>使用临时有序节点的原因：<br>使用有序节点是因为获取锁的顺序是按照节点的顺序来获取的。<br>使用临时节点的原因是：使用持久化节点有一个弊端，就是当客户端在释放锁之前失去连接，导致没有删除节点，此时又是持久化节点，就会形成一个死锁。如果是临时节点的话，客户端会话超时后，就会自动删除该节点释放锁，就不会形成死锁。</p>
<p>demo（代码上的注释很重要）：</p>
<p>/**</p>
<ul>
<li>@author YeHaocong</li>
<li>@decription 分布式锁 ，用线程模拟进程</li>
<li>/</li>
</ul>
<p>public class DistributedWriteLock implements IZkDataListener{</p>
<pre><code>//模拟多个进程的共享数据
private static int count = 0;
//ZkClient客户端
private ZkClient zkClient = ZkClientDemo.getZkClient();
//父节点路径
private static final String PARENT = &quot;/locks&quot;;
//节点的数据
private static final byte[] DEFAULT_DATA = &quot;&quot;.getBytes();
//锁的路径，只要当前最小的路径等于该路径，就证明该客户端获得了锁
private String lockPath;
//发令器
private CountDownLatch latch;

/**
 * 获取锁的方法
 */
public   void  lock()&#123;
    //创建一个临时有序节点，有序节点是必须的，临时节点是可以在客户端会话连接超时，无法删除节点时自动删除节点，释放锁。
    lockPath = zkClient.createEphemeralSequential(PARENT + &quot;/&quot;,DEFAULT_DATA);
    String threadName = Thread.currentThread().getName();
    //节点创建了，就开始竞争锁了。
    System.out.println(&quot;进程&quot; + threadName + &quot;创建节点了&quot; + lockPath + &quot;开始竞争锁&quot;);
    //获取父节点下的所有子节点
    List&lt;String&gt; children = zkClient.getChildren(PARENT);
    //将子节点排序，不过要加上PARENT前缀，因为获取子节点的路径只是节点的名称，不是全路径
    TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;();
    for (String child:children)&#123;
        treeSet.add(PARENT +&quot;/&quot;+ child);
    &#125;
    //获取有序节点中最小的 节点
    String canGetLockNode = treeSet.first();
    if (lockPath.equals(canGetLockNode))&#123;
        //如果当前客户端所创建的节点与最小的节点是同一节点，就获取到了锁。
        System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
    &#125;else &#123;

        //不一样就获取不到锁。就要阻塞住
        latch = new CountDownLatch(1);
        //获取当前客户端创建的节点的上一个节点，也就是排序后，刚好比它小的上一个节点
        String previousNode = treeSet.headSet(lockPath).last();

        //当前客户端监听该节点，当该节点被删除时，也就是释放锁的时刻，就唤醒该进程获得锁。
        zkClient.subscribeDataChanges(previousNode,this);

        if (!zkClient.exists(previousNode))&#123;
            //这里有一种情况，就是在当前客户端监听previousNode节点之前，该节点就已经被删除了，此时客户端就监听不到
            //previousNode节点的删除事件，因为监听前都被删除了，此时就无法调用回调函数唤醒进程。
            //所以在阻塞进程之前，就要进行一次判断，判断该节点是否已经被删除，如果删除了，就代表已经释放锁了，这里
            //就直接不用当前进程不用阻塞，直接就获取锁就行了。
            System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
        &#125;else &#123;
            //假如监听前节点没被删除，此时就是正确的监听了。
            //这里还有一种情况，就是假如我监听了之后，还没来得及进入这里节点被删除了，触发了节点删除事件，
            //发令器latch的值被countDown减为0，下面的阻塞latch.await()等于无效，这种情况也符合了逻辑。

            //如果正常情况，下面阻塞住了当前进程，当监听的节点被删除时，就会触发节点删除事件，在回调函数中就会把
            //发令器减为0唤醒被阻塞的进程。
            try &#123;
                latch.await();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
        &#125;

    &#125;
&#125;

/**
 * 释放锁的方法
 */
public  void unLock()&#123;
    //就是直接删除节点
    zkClient.delete(lockPath);
    System.out.println(&quot;进程&quot; + Thread.currentThread().getName() + &quot;释放了分布式锁&quot;);
&#125;


@Override
public void handleDataChange(String s, Object o) throws Exception &#123;

&#125;

@Override
public void handleDataDeleted(String s) throws Exception &#123;
    //节点被删除后，就触发了该事件回调，把发令器减一，唤醒进程
    latch.countDown();
&#125;

//测试
public static void main(String[] args) &#123;
    //模拟10个进程区抢分布式锁
    CountDownLatch latch = new CountDownLatch(10);
    for (int i = 0;i&lt;10;i++)&#123;
        Thread thread = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    //先阻塞住，等所有进程准备好就一个唤醒
                    latch.await();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                //创建一个分布式锁对象。用于争取分布式锁
                DistributedWriteLock fenBuShiSuo = new DistributedWriteLock();
                //争取锁，如果获取到了，就直接执行下面的逻辑，获取不到就阻塞住，等待锁的释放。
                fenBuShiSuo.lock();
                //对共享资源的操作
                count ++ ;
                //操作完就释放锁
                fenBuShiSuo.unLock();

            &#125;
        &#125;);
        //启动
        thread.start();
        latch.countDown();
    &#125;

    try &#123;
        //主进程睡眠50秒，等待count的最终值
        TimeUnit.SECONDS.sleep(50);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    System.out.println(&quot;count=&quot; + count);
&#125;
</code></pre>
<p>}</p>
<p><img src="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428231946.png" alt="img"></p>
<p>第二种<br>步骤：</p>
<p>需要访问某共享资源的节点进程，往Zookeeper的同一父节点（比如/locks）下去创建同一个临时节点（节点路径一致）。<br>因为只能有一个进程能创建成功，其他进程会报错节点已经存在，创建成功就等于获得锁。失败就监听该节点的删除事件并进入阻塞状态，等待锁的释放（删除节点）。<br>一旦锁释放（节点被删除）了，就会调用回调方法，唤醒所有线程再次创建该节点，此时也只能有一个进程创建成功，获取锁。<br>第二种方法就不实现了，逻辑比第一种要简单一点。</p>
<p>两种方法比较：<br>第一种方法：每次获得锁的进程是确定的，因为创建的临时有序节点小的进程就会先获取到锁，并且每次释放锁之后都只会唤醒一个进程。<br>第二种方法：每次获得锁的进程是不确定的，因为不知道哪个进程会创建节点成功，并且每次释放锁之后会唤醒所有进程进行抢占锁。</p>
<p>分布式共享锁的原理和实现<br>共享锁的特点是：在读操作时可以进行读操作，在读操作时不能进行写操作，在写操作时不能进行读操作和写操作。</p>
<p>共享锁的实现逻辑要比排它锁复杂很多。</p>
<p>所以使用Zookeeper实现共享锁的步骤如下：</p>
<p>需要访问某共享资源的节点进程，往Zookeeper的同一父节点（比如/locks）下去创建一个临时有序节点。此时创建的节点分为读节点和写节点。可以用前缀指定或者用节点值指定。<br>按顺序第一个写节点前的所有读节点都可以获取到锁同时进行读操作。<br>当前写节点为w1，上一个写节点为w2，w2应该监听w1与w2之后的所有读节点，这些读节点全部释放锁（删除后）才到该写节点w2获取锁。有一种情况是w1和w2是相邻，中间没有读节点，此时w2就要监听w1，直到w1释放锁w2才能获取锁。<br>读节点就要监听上一个写节点，该写节点释放锁就能获取锁。<br>总结步骤是：先处理最小写节点前面的读节点、再处理最小写节点、最后处理最小写节点后面的节点。</p>
<p>比如锁顺序<br>r1-r2-w3-r4-r5-w6-w7-r8-r9-w10<br>第一步：获取最小的写节点，也就是w3，然后让前面的两个读操作r1、r2获取锁，然后w3，监听r1、r2节点。<br>第二步：r4、r5监听w3节点，w6监听r4、r5节点，w7监听w6节点，r8、r9监听监听w7节点，w10监听r8、r9节点。</p>
<p>比如锁顺序<br>w1-r2-w3-r4-r5-w6-w7-r8-r9-w10<br>第一步：获取到第一个写节点w1，发现前面没有读节点，直接获取锁。<br>第二步：r2监听w1，w3监听r2，r4、r5监听w3，w6监听r4、r5节点，w7监听w6节点，r8、r9监听监听w7节点，w10监听r8、r9节点。</p>
<p>比如锁顺序：<br>r1-r2-r3-r4-r5<br>此时没有写节点，所以获取到的最小写节点为null，此时直接让所有读节点获取锁。</p>
<p>比如锁顺序：<br>w1-w2-w3-w4-w5<br>此时没有读节点，这里就跟排它锁一样。</p>
<p>代码（注释很重要）：</p>
<p>/**</p>
<ul>
<li>@author YeHaocong</li>
<li>@decription Zookeeper分布式共享锁实现</li>
<li>/</li>
</ul>
<p>public class DistributedReadLock implements IZkDataListener{<br>    //模拟多个进程的共享数据<br>    private static int count = 0;</p>
<pre><code>//读节点的前缀。
private static final String READ_PREFIX = &quot;r-&quot;;

//写节点的前缀。
private static final String WRITE_PREFIX = &quot;w-&quot;;

//这里就限定死读节点前缀与写节点前缀一样长了。为了使逻辑简单一些
private static final int PREFIX_LENGTH = WRITE_PREFIX.length();

//ZkClient客户端
private ZkClient zkClient = ZkClientDemo.getZkClient();

//父节点路径
//父节点的路径上都不能带有 读节点前缀 或者写节点前缀，不然就会使得逻辑不能符合预期
private static final String PARENT = &quot;/readLocks&quot;;
//节点的数据
private static final byte[] DEFAULT_DATA = &quot;&quot;.getBytes();

//锁的路径，只要当前最小的路径等于该路径，就证明该客户端获得了锁
private String lockPath;

//是读节点还是写节点true是读节点
private Boolean isRead;
//发令器
private CountDownLatch latch;

//当前锁路径创建的lockEntry  键时把路径前缀w-或者r-去掉，值就是锁的全路径
private Map.Entry&lt;String,String&gt; lockEntry;

//两个写节点之前已经释放了锁的节点路径会被记录到这里。用于防止重复释放锁
private Set&lt;String&gt; readNodesSets = new CopyOnWriteArraySet&lt;&gt;();


public DistributedReadLock(boolean isRead)&#123;
    this.isRead = isRead;
&#125;

/**
 * 获取锁的方法
 * isRead  是否是读节点、
 */
public   void  lock()&#123;
    //创建一个临时有序节点，有序节点是必须的，临时节点是可以在客户端会话连接超时，无法删除节点时自动删除节点，释放锁,防止死锁。
    if (isRead)&#123;
        //如果是读进程，就创建读节点 r-开头
        lockPath = zkClient.createEphemeralSequential(PARENT + &quot;/&quot; +  READ_PREFIX,DEFAULT_DATA);
    &#125;else &#123;
        //如果是写进程，就创建写节点 w- 开头
        lockPath = zkClient.createEphemeralSequential(PARENT + &quot;/&quot; + WRITE_PREFIX,DEFAULT_DATA);
    &#125;

    //获取当前线程名称
    String threadName = Thread.currentThread().getName();
    //节点创建了，就开始竞争锁了。
    System.out.println(&quot;进程&quot; + threadName + &quot;创建节点了&quot; + lockPath + &quot;开始竞争锁&quot;);
    //获取父节点下的所有子节点
    List&lt;String&gt; children = zkClient.getChildren(PARENT);
    //将子节点存进有排序功能的TreeMap里，键是子节点路径把前缀去掉，值是节点的全路径
    TreeMap&lt;String,String&gt; treeMap = new TreeMap&lt;&gt;();
    String key = null;
    for (String child:children)&#123;
        //因为前缀会影响实际的排序。
        // 例如本来w-1要排在r-2前面，由于w比r大，就会变得r-2排在w-1前面，所以排序前要把前缀去掉，作为treemap的key来由treemap排序

        //把子节点的前缀去掉，只剩下Zookeeper为我们生成的带顺序的后缀
        String tempChild = child.substring(PREFIX_LENGTH);

        //把节点补上父节点路径作为treemap的值
        String childWithParent = PARENT + &quot;/&quot; + child;

        //记录 当前 lockPath的key，用于下面保存一个lockEntry到本地
        if (childWithParent.equals(lockPath))
            key = tempChild;
        treeMap.put(tempChild,childWithParent);
    &#125;
    //保存到本地
    lockEntry = treeMap.floorEntry(key);

    //获取子节点中最小的写节点
    Map.Entry&lt;String,String&gt; minWriteNode = null;
    for (Map.Entry&lt;String,String&gt; entry:treeMap.entrySet())&#123;
        if (entry.getValue().contains(WRITE_PREFIX))&#123;
            minWriteNode = entry;
            break;
        &#125;
    &#125;

    if (minWriteNode == null)&#123;
        //如果minWriteNode为null 表示没有写节点，表示全部都是读操作，直接就全部都能获取锁。
        System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
        return;
    &#125;
    //获取最小的写节点前面的读节点,这些首先获取到锁，并且能够同时获取锁。
    //headMap方法时获取比指定key小的treeMap集合。默认不包括指定key。
    SortedMap&lt;String,String&gt; readNodes = treeMap.headMap(minWriteNode.getKey());
    //获取最小的写节点后面的所有节点集合,tailMap与headMap方法不同，headMap方法默认是不包括本节点的，tailMap默认是包括的。
    //我们要让他不包括
    NavigableMap&lt;String,String&gt; afterNodes = treeMap.tailMap(minWriteNode.getKey(),false);

    //最小写节点前面有读节点的情况，也就是最小写节点不是最小节点的情况
    if (!readNodes.isEmpty())&#123;
        if (readNodes.containsValue(lockPath))&#123;
            //如果当前的进程锁创建的节点是readNodes的元素的话，就直接获取锁。
            System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
        &#125;else &#123;
            //如果当前的进程锁创建的节点是readNodes的元素的情况
            if (lockPath.equals(minWriteNode.getValue()))&#123;
                //如果当前的进程锁创建的节点是最小写节点的话，就进入这里
                //创建一个发令器，发令器的count为最小写节点前面的读节点个数，因为写节点获取锁要等到前面的读节点全部释放后才能获取锁，
                //所以每一个读节点释放锁了，latch就countdown一次，知道所以读节点释放了，count就为0，就换唤醒该进程
                latch = new CountDownLatch(readNodes.size());
                for (Map.Entry&lt;String,String&gt; entry:readNodes.entrySet())&#123;
                    //遍历最小写节点前面的读节点，使用最小写节点的客户端区监听这些读节点的删除事件。
                    zkClient.subscribeDataChanges(entry.getValue(),this);
                    if (!zkClient.exists(entry.getValue()))&#123;
                        //这个判断是防止监听该读节点前该读节点就已经被删除了，这样的话，就不会触发该读节点的删除事件了。这里就要防止这个情况。

                        //还要做多一层判断，判断该读节点的删除事件回调是否已经被执行，使用readNodesSets中是否包含该节点判断，包含的话就证明
                        //该读节点的删除事件回调是否已经被执行，这里就不用重复执行一次是否锁的操作。
                        if (!readNodesSets.contains(entry.getValue()))&#123;
                            //如果读节点已经被删除，但是读节点的删除事件没有触发，也就是监听该读节点前，该读节点已经被删除了，就在这里释放锁。
                            //使用latch.countDown();释放。
                            latch.countDown();
                            //释放之后把他加到已释放读锁集合里。
                            readNodesSets.add(entry.getValue());

                        &#125;


                    &#125;
                &#125;
                try &#123;
                    //阻塞当前写进程，直到读节点全部释放锁。latch的count值就为0，就会唤醒该进程，获取锁。
                    latch.await();
                    System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;else &#123;
                //处理最小写节点后面的节点，不包括最小写节点。
                handElseNode(minWriteNode,afterNodes,threadName);
            &#125;


        &#125;
    &#125;
    //当最小写节点是最小节点，也就是最小写节点前面没有读节点的情况
    else &#123;
        //判断当前进程是不是最小写节点的进程，是就直接获取锁。
        if (lockPath.equals(minWriteNode.getValue()))
            System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
        //处理最小写节点后面的节点，不包括最小写节点。
        handElseNode(minWriteNode,afterNodes,threadName);
    &#125;

&#125;

/**
 * 处理最小写节点后面的节点，不包括最小写节点。
 * @param minWriteNode  最小写节点
 * @param afterNodes  最小写节点后面的节点，不包括最小写节点。
 * @param threadName  进程名称
 */
private void handElseNode(Map.Entry&lt;String,String&gt; minWriteNode,NavigableMap&lt;String,String&gt; afterNodes,
                          String threadName)&#123;


        //当前进程的节点是读节点的情况,读节点就要监控比它小，并且离他最近的写节点
        if (lockEntry.getValue().contains(READ_PREFIX))&#123;
            //获取比当前进程节点小的节点集合
            NavigableMap&lt;String,String&gt; stringStringNavigableMap = (NavigableMap&lt;String, String&gt;) afterNodes.headMap(lockEntry.getKey());
            //把节点顺序进行翻转。比如 本来比它小的节点结合有 w-2、r-3、r-4、w-5、r-6、r-7，如果要顺序遍历找到比它小，并且离他最近的写节点的话比较困难
            //因为不到最后都不知道哪个是离他最近的写节点，所以将他反过来遍历，遍历到的第一个写节点就是离它最近的写节点，也就是w5
            NavigableMap&lt;String, String&gt; tempMap = stringStringNavigableMap.descendingMap();

            Map.Entry&lt;String,String&gt; preWriteNodeEntry = null;
            for (Map.Entry&lt;String,String&gt; tempEntry:tempMap.entrySet())&#123;
                //遍历，找到离它最近的写节点
                if (tempEntry.getValue().contains(WRITE_PREFIX))&#123;
                    preWriteNodeEntry = tempEntry;
                    break;
                &#125;
            &#125;
            //如果找不到离它最近的写节点，因为最小写节点不包含在afterNodes里面，所以如果离读节点最近的写节点是最小写节点的话，就会获取不到，获取不到时，就
            //把最小写节点赋值给最近写节点。
            preWriteNodeEntry = preWriteNodeEntry == null?minWriteNode:preWriteNodeEntry;
            //获取最近写节点的路径。
            String preWriteNode = preWriteNodeEntry.getValue();
            //因为读节点只需监听一个写节点，所以latch的count为1
            latch = new CountDownLatch(1);
            zkClient.subscribeDataChanges(preWriteNode,this);
            if (!zkClient.exists(preWriteNode))&#123;
                //这里防止监听最近写节点前该写节点就被删除了，导致无法触发删除事件的情况发生。因为已经被删除（释放锁）了，所以该读节点就可以直接获取锁。
                System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
            &#125;else &#123;
                try &#123;
                    //阻塞当前读节点，直至最近写节点释放锁。就会被唤醒
                    latch.await();
                    System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;

        &#125;
        //当前进程的节点是写节点的情况,要监听它与他上一个写节点之间的读节点，比如当前写节点是w8，r4、 w5、r6、r7、w8,就要监听w5与w8之间的读节点r6、r7。
        else &#123;
            //获取比当前进程写节点小的节点，也就是 r4、 w5、r6、r7
            NavigableMap&lt;String,String&gt; stringStringNavigableMap = (NavigableMap&lt;String, String&gt;) afterNodes.headMap(lockEntry.getKey());
            //因为首先要找到最近写节点w5，才能获取他们之间的读节点，这个如果正常遍历的话要遍历到最后才能确定最近写节点，但是如果反向遍历的话。
            // r7、r6、w5、r4  我就可以直接遍历到r7就把 他添加到集合，遍历r6就把他添加到集合，遍历到的第一个写节点就是最近写节点，就直接停止遍历。
            //所以此处将map节点顺序反过来了
            NavigableMap&lt;String, String&gt; tempMap = stringStringNavigableMap.descendingMap();
            //记录两写节点间的读节点的集合
            TreeMap&lt;String,String&gt; readNodesMap = new TreeMap&lt;&gt;();
            //记录最近写节点
            Map.Entry&lt;String,String&gt; preWriteNodeEntry = null;
            for (Map.Entry&lt;String,String&gt; tempEntry:tempMap.entrySet())&#123;
                if (tempEntry.getValue().contains(WRITE_PREFIX))&#123;
                    //如果遍历到写节点，就是最近写节点，直接复制给preWriteNodeEntry，然后终止循环
                    preWriteNodeEntry = tempEntry;
                    break;
                &#125;
                //还没遍历到写节点，就把读节点添加到集合中。
                readNodesMap.put(tempEntry.getKey(),tempEntry.getValue());
            &#125;
            //stringStringNavigableMap没有写节点，就是最近写节点是最小写节点preWriteNodeEntry
            preWriteNodeEntry = preWriteNodeEntry == null?minWriteNode:preWriteNodeEntry;
            //创建latch，count值是两写节点之间的读节点个数。
            latch = new CountDownLatch(readNodesMap.size());

            //分两种情况，这里这种是两个写节点之间有读节点的情况。
            if (!readNodesMap.isEmpty())&#123;
                //这里就像处理上面的最小写节点前面有读节点的操作一样。
                for (Map.Entry&lt;String,String&gt; tempEntry:readNodesMap.entrySet())&#123;

                    zkClient.subscribeDataChanges(tempEntry.getValue(),this);
                    if (!zkClient.exists(tempEntry.getValue()))&#123;
                        if (!readNodesSets.contains(tempEntry.getValue()))&#123;
                            latch.countDown();
                            readNodesSets.add(tempEntry.getValue());

                        &#125;

                    &#125;

                &#125;
                try &#123;
                    latch.await();
                    System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            //这是另外一种情况，就是两个写节点是挨着的，就是中间没有读节点，比如w5,w6，当前节点是w6，这种情况w6就要监听w5节点，
            //当w5节点释放他就唤醒获取锁
            else &#123;
                //监控上一个写节点，比如w5
                zkClient.subscribeDataChanges(preWriteNodeEntry.getValue(),this);
                //创建latch
                latch = new CountDownLatch(1);
                if (!lockPath.equals(minWriteNode.getValue()))&#123;
                    if (!zkClient.exists(preWriteNodeEntry.getValue()))&#123;
                        //防止还没监听相邻写节点之前就相邻写节点就被删除的情况
                        System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
                    &#125;
                    try &#123;
                        //阻塞，直至相邻写节点释放。
                        latch.await();
                        System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;

                &#125;

            &#125;

        &#125;


&#125;


/**
 * 释放锁的方法
 */
public  void unLock()&#123;
    //就是直接删除节点
    zkClient.delete(lockPath);
    System.out.println(&quot;释放了分布式锁,节点[&quot; + lockPath + &quot;]&quot;);
&#125;

@Override
public void handleDataChange(String s, Object o) throws Exception &#123;

&#125;

@Override
public void handleDataDeleted(String s) throws Exception &#123;
    synchronized (readNodesSets)&#123;
        if (!readNodesSets.contains(s))&#123;
            latch.countDown();
            readNodesSets.add(s);

        &#125;
    &#125;


&#125;

public static void main(String[] args) &#123;
    //模拟10个进程区抢分布式读锁  ,7个读进程、3个写进程
    CountDownLatch latch = new CountDownLatch(10);
    for (int i = 0;i&lt;7;i++)&#123;
        Thread thread = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    //先阻塞住，等所有进程准备好就一个唤醒
                    latch.await();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                //创建一个分布式锁对象。用于争取分布式锁
                DistributedReadLock distributedReadLock = new DistributedReadLock(true);
                //争取锁，如果获取到了，就直接执行下面的逻辑，获取不到就阻塞住，等待锁的释放。
                distributedReadLock.lock();
                //对共享资源的操作
                System.out.println(&quot;读进程&quot; + Thread.currentThread().getName() + &quot;读到的count = &quot; + count);
                //操作完就释放锁
                distributedReadLock.unLock();

            &#125;
        &#125;);
        //启动
        thread.start();
        latch.countDown();
    &#125;
    for (int i = 0;i&lt;3;i++)&#123;
        Thread thread = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    //先阻塞住，等所有进程准备好就一个唤醒
                    latch.await();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                //创建一个分布式锁对象。用于争取分布式锁
                DistributedReadLock distributedReadLock = new DistributedReadLock(false);
                //争取锁，如果获取到了，就直接执行下面的逻辑，获取不到就阻塞住，等待锁的释放。
                distributedReadLock.lock();
                //对共享资源的操作
                System.out.println(Thread.currentThread().getName() + &quot;执行写操作&quot;);
                count ++ ;
                //操作完就释放锁
                distributedReadLock.unLock();

            &#125;
        &#125;);
        //启动
        thread.start();
        latch.countDown();
    &#125;

    try &#123;
        //主进程睡眠50秒，等待count的最终值
        TimeUnit.SECONDS.sleep(30);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    System.out.println(&quot;count=&quot; + count);
&#125;
</code></pre>
<p>}</p>
<p><img src="https://img-blog.csdnimg.cn/20200706175038752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODM3MzEw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>由结果可知：<br>锁的顺序是<br>r-0 、r-1 、w-2 、r-3 、r-4 、w-5 、r-6 、r-7 、r-8 、w-9<br>所以获取锁的顺序是</p>
<p>r-0和r-1能同时获取锁。<br>等r-0和r-1都释放了锁，w-2就获取锁。<br>等w-2释放了锁 r-3和r-4就能同时获取锁。<br>等 r-3和r-4都释放了锁，w-5就能获取锁。<br>等w-5释放了锁，r-6 、r-7 、r-8 就能同时获得锁。<br>等r-6 、r-7 、r-8 都释放了锁，w-9就能获得锁。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="dubbo-超时设置过长"><a href="#dubbo-超时设置过长" class="headerlink" title="dubbo 超时设置过长"></a>dubbo 超时设置过长</h3><p>dubbo 接口超时时间设置过长 内部采用轮询机制  消息生产者其中一台服务老是定时重启 导致接口阻塞 导致服务宕机</p>
<p>解决方法 超时时间设短</p>
<h3 id="truncate问题"><a href="#truncate问题" class="headerlink" title="truncate问题"></a>truncate问题</h3><p>其反应truncate表时 别的所有业务都阻塞</p>
<p>解决方式是，测试用的表和线上的库隔离，或者升级mysql到8.0</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/Mysql%E4%BC%98%E5%8C%96%E4%B9%8B%E7%B2%BE%E9%AB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vivid">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vivid的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/25/Mysql%E4%BC%98%E5%8C%96%E4%B9%8B%E7%B2%BE%E9%AB%93/" class="post-title-link" itemprop="url">Mysql优化之精髓</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-25 22:35:49 / 修改时间：22:43:30" itemprop="dateCreated datePublished" datetime="2021-04-25T22:35:49+08:00">2021-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h2><ul>
<li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li>
<li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li>
<li>数据是存放在磁盘上的，读写速度无法和内存相比</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/25/Mysql%E4%BC%98%E5%8C%96%E4%B9%8B%E7%B2%BE%E9%AB%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/java%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vivid">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vivid的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/25/java%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">java面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-25 22:27:47 / 修改时间：22:29:14" itemprop="dateCreated datePublished" datetime="2021-04-25T22:27:47+08:00">2021-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/25/java%E9%9D%A2%E8%AF%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/Elasticsearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vivid">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vivid的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/25/Elasticsearch/" class="post-title-link" itemprop="url">Elasticsearch</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-25 22:04:31" itemprop="dateCreated datePublished" datetime="2021-04-25T22:04:31+08:00">2021-04-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-09 22:38:19" itemprop="dateModified" datetime="2021-05-09T22:38:19+08:00">2021-05-09</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">大数据相关</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p>ElasticSearch:<a target="_blank" rel="noopener" href="https://mirrors.huaweicloud.com/elasticsearch/?C=N&O=D">https://mirrors.huaweicloud.com/elasticsearch/?C=N&amp;O=D</a></p>
<p>logstash:<a target="_blank" rel="noopener" href="https://mirrors.huaweicloud.com/logstash/?C=N&O=D">https://mirrors.huaweicloud.com/logstash/?C=N&amp;O=D</a></p>
<p>kibana:<a target="_blank" rel="noopener" href="https://mirrors.huaweicloud.com/kibana/?C=N&O=D">https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/25/Elasticsearch/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vivid">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vivid的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-24 22:24:45" itemprop="dateCreated datePublished" datetime="2021-04-24T22:24:45+08:00">2021-04-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-25 22:16:23" itemprop="dateModified" datetime="2021-04-25T22:16:23+08:00">2021-04-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npx hexo new &quot;postName&quot; #新建文章</span><br><span class="line">npx hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">npx hexo generate #生成静态页面至public目录</span><br><span class="line">npx hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">npx hexo deploy #部署到GitHub</span><br><span class="line">npx hexo help  # 查看帮助</span><br><span class="line">npx hexo version  #查看Hexo的版本</span><br><span class="line"></span><br><span class="line">npx hexo s -g #生成并本地预览</span><br><span class="line">npx hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vivid</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
