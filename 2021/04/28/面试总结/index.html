<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="java cpu 满载怎么定位top |grep java 或者 jps指令找到java进程的pid（6167） top -H -p pid  以线程的形式查看该进程 top -H -p 6167  前面的线程ID是10进制的，，需要转换成16进制，，因为等下在jstack命令取出来的线程ID是16进制的：这里就随便选一个线程ID 去转换了，真实环境肯定是选择CPU占用率最高的那个线程 1ec">
<meta property="og:type" content="article">
<meta property="og:title" content="面试总结">
<meta property="og:url" content="http://example.com/2021/04/28/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="vivid的博客">
<meta property="og:description" content="java cpu 满载怎么定位top |grep java 或者 jps指令找到java进程的pid（6167） top -H -p pid  以线程的形式查看该进程 top -H -p 6167  前面的线程ID是10进制的，，需要转换成16进制，，因为等下在jstack命令取出来的线程ID是16进制的：这里就随便选一个线程ID 去转换了，真实环境肯定是选择CPU占用率最高的那个线程 1ec">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428214822.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428215138.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428215709.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428231946.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200706175038752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODM3MzEw,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2021-04-28T13:36:41.000Z">
<meta property="article:modified_time" content="2021-04-28T15:22:07.230Z">
<meta property="article:author" content="vivid">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428214822.png">


<link rel="canonical" href="http://example.com/2021/04/28/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;04&#x2F;28&#x2F;%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;04&#x2F;28&#x2F;面试总结&#x2F;&quot;,&quot;title&quot;:&quot;面试总结&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>面试总结 | vivid的博客</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">vivid的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#java-cpu-%E6%BB%A1%E8%BD%BD%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D"><span class="nav-number">1.</span> <span class="nav-text">java cpu 满载怎么定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">微服务序列化方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zk%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">zk实现分布式共享锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">遇到的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dubbo-%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE%E8%BF%87%E9%95%BF"><span class="nav-number">4.1.</span> <span class="nav-text">dubbo 超时设置过长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#truncate%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.</span> <span class="nav-text">truncate问题</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">vivid</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/28/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vivid">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vivid的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-28 21:36:41 / 修改时间：23:22:07" itemprop="dateCreated datePublished" datetime="2021-04-28T21:36:41+08:00">2021-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <span id="more"></span>

<h2 id="java-cpu-满载怎么定位"><a href="#java-cpu-满载怎么定位" class="headerlink" title="java cpu 满载怎么定位"></a>java cpu 满载怎么定位</h2><p>top |grep java 或者 jps指令找到java进程的pid（6167）</p>
<p>top -H -p pid  以线程的形式查看该进程 top -H -p 6167</p>
<p><img src="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428214822.png" alt="image-20210428214818372"></p>
<p>前面的线程ID是10进制的，，需要转换成16进制，，因为等下在jstack命令取出来的线程ID是16进制的：这里就随便选一个线程ID 去转换了，真实环境肯定是选择CPU占用率最高的那个线程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;obase=16;6219&quot; | bc</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428215138.png" alt="image-20210428215134492"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 6167 &gt;threadInfo.txt</span><br></pre></td></tr></table></figure>

<p> 信息输出到文件 然后查看。也可以直接在命令里面查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428215709.png" alt="img"></p>
<h2 id="微服务序列化方式"><a href="#微服务序列化方式" class="headerlink" title="微服务序列化方式"></a>微服务序列化方式</h2><p>Dubbo 支持多种序列化方式：JDK自带的序列化、hessian2、JSON、Kryo、FST、Protostuff，ProtoBuf等等。</p>
<p>Dubbo 默认使用的序列化方式是 hession2。</p>
<p>一般我们不会直接使用 JDK 自带的序列化方式。主要原因有两个：</p>
<ol>
<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
</ol>
<p>JSON 序列化由于性能问题，我们一般也不会考虑使用。</p>
<p>像 Protostuff，ProtoBuf、hessian2这些都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p>
<p>Kryo和FST这两种序列化方式是 Dubbo 后来才引入的，性能非常好。不过，这两者都是专门针对 Java 语言的。Dubbo 官网的一篇文章中提到说</p>
<h2 id="zk实现分布式共享锁"><a href="#zk实现分布式共享锁" class="headerlink" title="zk实现分布式共享锁"></a>zk实现分布式共享锁</h2><p>第一种<br>步骤：</p>
<p>需要访问某共享资源的节点进程，往Zookeeper的同一父节点（比如/locks）下去创建一个临时有序节点。<br>每个进程获取该父节点下的子节点列表，并且获取一个最小的子节点的路径，与当前自己创建的临时有序节点是否是同一节点，是的话就获取锁，不是的话就获取锁失败。<br>获取锁失败后，需要监听比它小的上一个节点的删除事件，并阻塞进程。一旦被监听的节点被删除了，触发了节点删除事件，在回调中就可以唤醒该进程进行获得锁。<br>主要就这三步，就可以使用Zookeeper实现一个分布式排它锁。<br>使用临时有序节点的原因：<br>使用有序节点是因为获取锁的顺序是按照节点的顺序来获取的。<br>使用临时节点的原因是：使用持久化节点有一个弊端，就是当客户端在释放锁之前失去连接，导致没有删除节点，此时又是持久化节点，就会形成一个死锁。如果是临时节点的话，客户端会话超时后，就会自动删除该节点释放锁，就不会形成死锁。</p>
<p>demo（代码上的注释很重要）：</p>
<p>/**</p>
<ul>
<li>@author YeHaocong</li>
<li>@decription 分布式锁 ，用线程模拟进程</li>
<li>/</li>
</ul>
<p>public class DistributedWriteLock implements IZkDataListener{</p>
<pre><code>//模拟多个进程的共享数据
private static int count = 0;
//ZkClient客户端
private ZkClient zkClient = ZkClientDemo.getZkClient();
//父节点路径
private static final String PARENT = &quot;/locks&quot;;
//节点的数据
private static final byte[] DEFAULT_DATA = &quot;&quot;.getBytes();
//锁的路径，只要当前最小的路径等于该路径，就证明该客户端获得了锁
private String lockPath;
//发令器
private CountDownLatch latch;

/**
 * 获取锁的方法
 */
public   void  lock()&#123;
    //创建一个临时有序节点，有序节点是必须的，临时节点是可以在客户端会话连接超时，无法删除节点时自动删除节点，释放锁。
    lockPath = zkClient.createEphemeralSequential(PARENT + &quot;/&quot;,DEFAULT_DATA);
    String threadName = Thread.currentThread().getName();
    //节点创建了，就开始竞争锁了。
    System.out.println(&quot;进程&quot; + threadName + &quot;创建节点了&quot; + lockPath + &quot;开始竞争锁&quot;);
    //获取父节点下的所有子节点
    List&lt;String&gt; children = zkClient.getChildren(PARENT);
    //将子节点排序，不过要加上PARENT前缀，因为获取子节点的路径只是节点的名称，不是全路径
    TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;();
    for (String child:children)&#123;
        treeSet.add(PARENT +&quot;/&quot;+ child);
    &#125;
    //获取有序节点中最小的 节点
    String canGetLockNode = treeSet.first();
    if (lockPath.equals(canGetLockNode))&#123;
        //如果当前客户端所创建的节点与最小的节点是同一节点，就获取到了锁。
        System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
    &#125;else &#123;

        //不一样就获取不到锁。就要阻塞住
        latch = new CountDownLatch(1);
        //获取当前客户端创建的节点的上一个节点，也就是排序后，刚好比它小的上一个节点
        String previousNode = treeSet.headSet(lockPath).last();

        //当前客户端监听该节点，当该节点被删除时，也就是释放锁的时刻，就唤醒该进程获得锁。
        zkClient.subscribeDataChanges(previousNode,this);

        if (!zkClient.exists(previousNode))&#123;
            //这里有一种情况，就是在当前客户端监听previousNode节点之前，该节点就已经被删除了，此时客户端就监听不到
            //previousNode节点的删除事件，因为监听前都被删除了，此时就无法调用回调函数唤醒进程。
            //所以在阻塞进程之前，就要进行一次判断，判断该节点是否已经被删除，如果删除了，就代表已经释放锁了，这里
            //就直接不用当前进程不用阻塞，直接就获取锁就行了。
            System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
        &#125;else &#123;
            //假如监听前节点没被删除，此时就是正确的监听了。
            //这里还有一种情况，就是假如我监听了之后，还没来得及进入这里节点被删除了，触发了节点删除事件，
            //发令器latch的值被countDown减为0，下面的阻塞latch.await()等于无效，这种情况也符合了逻辑。

            //如果正常情况，下面阻塞住了当前进程，当监听的节点被删除时，就会触发节点删除事件，在回调函数中就会把
            //发令器减为0唤醒被阻塞的进程。
            try &#123;
                latch.await();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
        &#125;

    &#125;
&#125;

/**
 * 释放锁的方法
 */
public  void unLock()&#123;
    //就是直接删除节点
    zkClient.delete(lockPath);
    System.out.println(&quot;进程&quot; + Thread.currentThread().getName() + &quot;释放了分布式锁&quot;);
&#125;


@Override
public void handleDataChange(String s, Object o) throws Exception &#123;

&#125;

@Override
public void handleDataDeleted(String s) throws Exception &#123;
    //节点被删除后，就触发了该事件回调，把发令器减一，唤醒进程
    latch.countDown();
&#125;

//测试
public static void main(String[] args) &#123;
    //模拟10个进程区抢分布式锁
    CountDownLatch latch = new CountDownLatch(10);
    for (int i = 0;i&lt;10;i++)&#123;
        Thread thread = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    //先阻塞住，等所有进程准备好就一个唤醒
                    latch.await();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                //创建一个分布式锁对象。用于争取分布式锁
                DistributedWriteLock fenBuShiSuo = new DistributedWriteLock();
                //争取锁，如果获取到了，就直接执行下面的逻辑，获取不到就阻塞住，等待锁的释放。
                fenBuShiSuo.lock();
                //对共享资源的操作
                count ++ ;
                //操作完就释放锁
                fenBuShiSuo.unLock();

            &#125;
        &#125;);
        //启动
        thread.start();
        latch.countDown();
    &#125;

    try &#123;
        //主进程睡眠50秒，等待count的最终值
        TimeUnit.SECONDS.sleep(50);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    System.out.println(&quot;count=&quot; + count);
&#125;
</code></pre>
<p>}</p>
<p><img src="https://cdn.jsdelivr.net/gh/MyhangsYourdream/cloud-img//img/20210428231946.png" alt="img"></p>
<p>第二种<br>步骤：</p>
<p>需要访问某共享资源的节点进程，往Zookeeper的同一父节点（比如/locks）下去创建同一个临时节点（节点路径一致）。<br>因为只能有一个进程能创建成功，其他进程会报错节点已经存在，创建成功就等于获得锁。失败就监听该节点的删除事件并进入阻塞状态，等待锁的释放（删除节点）。<br>一旦锁释放（节点被删除）了，就会调用回调方法，唤醒所有线程再次创建该节点，此时也只能有一个进程创建成功，获取锁。<br>第二种方法就不实现了，逻辑比第一种要简单一点。</p>
<p>两种方法比较：<br>第一种方法：每次获得锁的进程是确定的，因为创建的临时有序节点小的进程就会先获取到锁，并且每次释放锁之后都只会唤醒一个进程。<br>第二种方法：每次获得锁的进程是不确定的，因为不知道哪个进程会创建节点成功，并且每次释放锁之后会唤醒所有进程进行抢占锁。</p>
<p>分布式共享锁的原理和实现<br>共享锁的特点是：在读操作时可以进行读操作，在读操作时不能进行写操作，在写操作时不能进行读操作和写操作。</p>
<p>共享锁的实现逻辑要比排它锁复杂很多。</p>
<p>所以使用Zookeeper实现共享锁的步骤如下：</p>
<p>需要访问某共享资源的节点进程，往Zookeeper的同一父节点（比如/locks）下去创建一个临时有序节点。此时创建的节点分为读节点和写节点。可以用前缀指定或者用节点值指定。<br>按顺序第一个写节点前的所有读节点都可以获取到锁同时进行读操作。<br>当前写节点为w1，上一个写节点为w2，w2应该监听w1与w2之后的所有读节点，这些读节点全部释放锁（删除后）才到该写节点w2获取锁。有一种情况是w1和w2是相邻，中间没有读节点，此时w2就要监听w1，直到w1释放锁w2才能获取锁。<br>读节点就要监听上一个写节点，该写节点释放锁就能获取锁。<br>总结步骤是：先处理最小写节点前面的读节点、再处理最小写节点、最后处理最小写节点后面的节点。</p>
<p>比如锁顺序<br>r1-r2-w3-r4-r5-w6-w7-r8-r9-w10<br>第一步：获取最小的写节点，也就是w3，然后让前面的两个读操作r1、r2获取锁，然后w3，监听r1、r2节点。<br>第二步：r4、r5监听w3节点，w6监听r4、r5节点，w7监听w6节点，r8、r9监听监听w7节点，w10监听r8、r9节点。</p>
<p>比如锁顺序<br>w1-r2-w3-r4-r5-w6-w7-r8-r9-w10<br>第一步：获取到第一个写节点w1，发现前面没有读节点，直接获取锁。<br>第二步：r2监听w1，w3监听r2，r4、r5监听w3，w6监听r4、r5节点，w7监听w6节点，r8、r9监听监听w7节点，w10监听r8、r9节点。</p>
<p>比如锁顺序：<br>r1-r2-r3-r4-r5<br>此时没有写节点，所以获取到的最小写节点为null，此时直接让所有读节点获取锁。</p>
<p>比如锁顺序：<br>w1-w2-w3-w4-w5<br>此时没有读节点，这里就跟排它锁一样。</p>
<p>代码（注释很重要）：</p>
<p>/**</p>
<ul>
<li>@author YeHaocong</li>
<li>@decription Zookeeper分布式共享锁实现</li>
<li>/</li>
</ul>
<p>public class DistributedReadLock implements IZkDataListener{<br>    //模拟多个进程的共享数据<br>    private static int count = 0;</p>
<pre><code>//读节点的前缀。
private static final String READ_PREFIX = &quot;r-&quot;;

//写节点的前缀。
private static final String WRITE_PREFIX = &quot;w-&quot;;

//这里就限定死读节点前缀与写节点前缀一样长了。为了使逻辑简单一些
private static final int PREFIX_LENGTH = WRITE_PREFIX.length();

//ZkClient客户端
private ZkClient zkClient = ZkClientDemo.getZkClient();

//父节点路径
//父节点的路径上都不能带有 读节点前缀 或者写节点前缀，不然就会使得逻辑不能符合预期
private static final String PARENT = &quot;/readLocks&quot;;
//节点的数据
private static final byte[] DEFAULT_DATA = &quot;&quot;.getBytes();

//锁的路径，只要当前最小的路径等于该路径，就证明该客户端获得了锁
private String lockPath;

//是读节点还是写节点true是读节点
private Boolean isRead;
//发令器
private CountDownLatch latch;

//当前锁路径创建的lockEntry  键时把路径前缀w-或者r-去掉，值就是锁的全路径
private Map.Entry&lt;String,String&gt; lockEntry;

//两个写节点之前已经释放了锁的节点路径会被记录到这里。用于防止重复释放锁
private Set&lt;String&gt; readNodesSets = new CopyOnWriteArraySet&lt;&gt;();


public DistributedReadLock(boolean isRead)&#123;
    this.isRead = isRead;
&#125;

/**
 * 获取锁的方法
 * isRead  是否是读节点、
 */
public   void  lock()&#123;
    //创建一个临时有序节点，有序节点是必须的，临时节点是可以在客户端会话连接超时，无法删除节点时自动删除节点，释放锁,防止死锁。
    if (isRead)&#123;
        //如果是读进程，就创建读节点 r-开头
        lockPath = zkClient.createEphemeralSequential(PARENT + &quot;/&quot; +  READ_PREFIX,DEFAULT_DATA);
    &#125;else &#123;
        //如果是写进程，就创建写节点 w- 开头
        lockPath = zkClient.createEphemeralSequential(PARENT + &quot;/&quot; + WRITE_PREFIX,DEFAULT_DATA);
    &#125;

    //获取当前线程名称
    String threadName = Thread.currentThread().getName();
    //节点创建了，就开始竞争锁了。
    System.out.println(&quot;进程&quot; + threadName + &quot;创建节点了&quot; + lockPath + &quot;开始竞争锁&quot;);
    //获取父节点下的所有子节点
    List&lt;String&gt; children = zkClient.getChildren(PARENT);
    //将子节点存进有排序功能的TreeMap里，键是子节点路径把前缀去掉，值是节点的全路径
    TreeMap&lt;String,String&gt; treeMap = new TreeMap&lt;&gt;();
    String key = null;
    for (String child:children)&#123;
        //因为前缀会影响实际的排序。
        // 例如本来w-1要排在r-2前面，由于w比r大，就会变得r-2排在w-1前面，所以排序前要把前缀去掉，作为treemap的key来由treemap排序

        //把子节点的前缀去掉，只剩下Zookeeper为我们生成的带顺序的后缀
        String tempChild = child.substring(PREFIX_LENGTH);

        //把节点补上父节点路径作为treemap的值
        String childWithParent = PARENT + &quot;/&quot; + child;

        //记录 当前 lockPath的key，用于下面保存一个lockEntry到本地
        if (childWithParent.equals(lockPath))
            key = tempChild;
        treeMap.put(tempChild,childWithParent);
    &#125;
    //保存到本地
    lockEntry = treeMap.floorEntry(key);

    //获取子节点中最小的写节点
    Map.Entry&lt;String,String&gt; minWriteNode = null;
    for (Map.Entry&lt;String,String&gt; entry:treeMap.entrySet())&#123;
        if (entry.getValue().contains(WRITE_PREFIX))&#123;
            minWriteNode = entry;
            break;
        &#125;
    &#125;

    if (minWriteNode == null)&#123;
        //如果minWriteNode为null 表示没有写节点，表示全部都是读操作，直接就全部都能获取锁。
        System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
        return;
    &#125;
    //获取最小的写节点前面的读节点,这些首先获取到锁，并且能够同时获取锁。
    //headMap方法时获取比指定key小的treeMap集合。默认不包括指定key。
    SortedMap&lt;String,String&gt; readNodes = treeMap.headMap(minWriteNode.getKey());
    //获取最小的写节点后面的所有节点集合,tailMap与headMap方法不同，headMap方法默认是不包括本节点的，tailMap默认是包括的。
    //我们要让他不包括
    NavigableMap&lt;String,String&gt; afterNodes = treeMap.tailMap(minWriteNode.getKey(),false);

    //最小写节点前面有读节点的情况，也就是最小写节点不是最小节点的情况
    if (!readNodes.isEmpty())&#123;
        if (readNodes.containsValue(lockPath))&#123;
            //如果当前的进程锁创建的节点是readNodes的元素的话，就直接获取锁。
            System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
        &#125;else &#123;
            //如果当前的进程锁创建的节点是readNodes的元素的情况
            if (lockPath.equals(minWriteNode.getValue()))&#123;
                //如果当前的进程锁创建的节点是最小写节点的话，就进入这里
                //创建一个发令器，发令器的count为最小写节点前面的读节点个数，因为写节点获取锁要等到前面的读节点全部释放后才能获取锁，
                //所以每一个读节点释放锁了，latch就countdown一次，知道所以读节点释放了，count就为0，就换唤醒该进程
                latch = new CountDownLatch(readNodes.size());
                for (Map.Entry&lt;String,String&gt; entry:readNodes.entrySet())&#123;
                    //遍历最小写节点前面的读节点，使用最小写节点的客户端区监听这些读节点的删除事件。
                    zkClient.subscribeDataChanges(entry.getValue(),this);
                    if (!zkClient.exists(entry.getValue()))&#123;
                        //这个判断是防止监听该读节点前该读节点就已经被删除了，这样的话，就不会触发该读节点的删除事件了。这里就要防止这个情况。

                        //还要做多一层判断，判断该读节点的删除事件回调是否已经被执行，使用readNodesSets中是否包含该节点判断，包含的话就证明
                        //该读节点的删除事件回调是否已经被执行，这里就不用重复执行一次是否锁的操作。
                        if (!readNodesSets.contains(entry.getValue()))&#123;
                            //如果读节点已经被删除，但是读节点的删除事件没有触发，也就是监听该读节点前，该读节点已经被删除了，就在这里释放锁。
                            //使用latch.countDown();释放。
                            latch.countDown();
                            //释放之后把他加到已释放读锁集合里。
                            readNodesSets.add(entry.getValue());

                        &#125;


                    &#125;
                &#125;
                try &#123;
                    //阻塞当前写进程，直到读节点全部释放锁。latch的count值就为0，就会唤醒该进程，获取锁。
                    latch.await();
                    System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;else &#123;
                //处理最小写节点后面的节点，不包括最小写节点。
                handElseNode(minWriteNode,afterNodes,threadName);
            &#125;


        &#125;
    &#125;
    //当最小写节点是最小节点，也就是最小写节点前面没有读节点的情况
    else &#123;
        //判断当前进程是不是最小写节点的进程，是就直接获取锁。
        if (lockPath.equals(minWriteNode.getValue()))
            System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
        //处理最小写节点后面的节点，不包括最小写节点。
        handElseNode(minWriteNode,afterNodes,threadName);
    &#125;

&#125;

/**
 * 处理最小写节点后面的节点，不包括最小写节点。
 * @param minWriteNode  最小写节点
 * @param afterNodes  最小写节点后面的节点，不包括最小写节点。
 * @param threadName  进程名称
 */
private void handElseNode(Map.Entry&lt;String,String&gt; minWriteNode,NavigableMap&lt;String,String&gt; afterNodes,
                          String threadName)&#123;


        //当前进程的节点是读节点的情况,读节点就要监控比它小，并且离他最近的写节点
        if (lockEntry.getValue().contains(READ_PREFIX))&#123;
            //获取比当前进程节点小的节点集合
            NavigableMap&lt;String,String&gt; stringStringNavigableMap = (NavigableMap&lt;String, String&gt;) afterNodes.headMap(lockEntry.getKey());
            //把节点顺序进行翻转。比如 本来比它小的节点结合有 w-2、r-3、r-4、w-5、r-6、r-7，如果要顺序遍历找到比它小，并且离他最近的写节点的话比较困难
            //因为不到最后都不知道哪个是离他最近的写节点，所以将他反过来遍历，遍历到的第一个写节点就是离它最近的写节点，也就是w5
            NavigableMap&lt;String, String&gt; tempMap = stringStringNavigableMap.descendingMap();

            Map.Entry&lt;String,String&gt; preWriteNodeEntry = null;
            for (Map.Entry&lt;String,String&gt; tempEntry:tempMap.entrySet())&#123;
                //遍历，找到离它最近的写节点
                if (tempEntry.getValue().contains(WRITE_PREFIX))&#123;
                    preWriteNodeEntry = tempEntry;
                    break;
                &#125;
            &#125;
            //如果找不到离它最近的写节点，因为最小写节点不包含在afterNodes里面，所以如果离读节点最近的写节点是最小写节点的话，就会获取不到，获取不到时，就
            //把最小写节点赋值给最近写节点。
            preWriteNodeEntry = preWriteNodeEntry == null?minWriteNode:preWriteNodeEntry;
            //获取最近写节点的路径。
            String preWriteNode = preWriteNodeEntry.getValue();
            //因为读节点只需监听一个写节点，所以latch的count为1
            latch = new CountDownLatch(1);
            zkClient.subscribeDataChanges(preWriteNode,this);
            if (!zkClient.exists(preWriteNode))&#123;
                //这里防止监听最近写节点前该写节点就被删除了，导致无法触发删除事件的情况发生。因为已经被删除（释放锁）了，所以该读节点就可以直接获取锁。
                System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
            &#125;else &#123;
                try &#123;
                    //阻塞当前读节点，直至最近写节点释放锁。就会被唤醒
                    latch.await();
                    System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;

        &#125;
        //当前进程的节点是写节点的情况,要监听它与他上一个写节点之间的读节点，比如当前写节点是w8，r4、 w5、r6、r7、w8,就要监听w5与w8之间的读节点r6、r7。
        else &#123;
            //获取比当前进程写节点小的节点，也就是 r4、 w5、r6、r7
            NavigableMap&lt;String,String&gt; stringStringNavigableMap = (NavigableMap&lt;String, String&gt;) afterNodes.headMap(lockEntry.getKey());
            //因为首先要找到最近写节点w5，才能获取他们之间的读节点，这个如果正常遍历的话要遍历到最后才能确定最近写节点，但是如果反向遍历的话。
            // r7、r6、w5、r4  我就可以直接遍历到r7就把 他添加到集合，遍历r6就把他添加到集合，遍历到的第一个写节点就是最近写节点，就直接停止遍历。
            //所以此处将map节点顺序反过来了
            NavigableMap&lt;String, String&gt; tempMap = stringStringNavigableMap.descendingMap();
            //记录两写节点间的读节点的集合
            TreeMap&lt;String,String&gt; readNodesMap = new TreeMap&lt;&gt;();
            //记录最近写节点
            Map.Entry&lt;String,String&gt; preWriteNodeEntry = null;
            for (Map.Entry&lt;String,String&gt; tempEntry:tempMap.entrySet())&#123;
                if (tempEntry.getValue().contains(WRITE_PREFIX))&#123;
                    //如果遍历到写节点，就是最近写节点，直接复制给preWriteNodeEntry，然后终止循环
                    preWriteNodeEntry = tempEntry;
                    break;
                &#125;
                //还没遍历到写节点，就把读节点添加到集合中。
                readNodesMap.put(tempEntry.getKey(),tempEntry.getValue());
            &#125;
            //stringStringNavigableMap没有写节点，就是最近写节点是最小写节点preWriteNodeEntry
            preWriteNodeEntry = preWriteNodeEntry == null?minWriteNode:preWriteNodeEntry;
            //创建latch，count值是两写节点之间的读节点个数。
            latch = new CountDownLatch(readNodesMap.size());

            //分两种情况，这里这种是两个写节点之间有读节点的情况。
            if (!readNodesMap.isEmpty())&#123;
                //这里就像处理上面的最小写节点前面有读节点的操作一样。
                for (Map.Entry&lt;String,String&gt; tempEntry:readNodesMap.entrySet())&#123;

                    zkClient.subscribeDataChanges(tempEntry.getValue(),this);
                    if (!zkClient.exists(tempEntry.getValue()))&#123;
                        if (!readNodesSets.contains(tempEntry.getValue()))&#123;
                            latch.countDown();
                            readNodesSets.add(tempEntry.getValue());

                        &#125;

                    &#125;

                &#125;
                try &#123;
                    latch.await();
                    System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            //这是另外一种情况，就是两个写节点是挨着的，就是中间没有读节点，比如w5,w6，当前节点是w6，这种情况w6就要监听w5节点，
            //当w5节点释放他就唤醒获取锁
            else &#123;
                //监控上一个写节点，比如w5
                zkClient.subscribeDataChanges(preWriteNodeEntry.getValue(),this);
                //创建latch
                latch = new CountDownLatch(1);
                if (!lockPath.equals(minWriteNode.getValue()))&#123;
                    if (!zkClient.exists(preWriteNodeEntry.getValue()))&#123;
                        //防止还没监听相邻写节点之前就相邻写节点就被删除的情况
                        System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
                    &#125;
                    try &#123;
                        //阻塞，直至相邻写节点释放。
                        latch.await();
                        System.out.println(&quot;进程&quot; + threadName + &quot;获得了分布式锁,节点是[&quot; + lockPath + &quot;]&quot;);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;

                &#125;

            &#125;

        &#125;


&#125;


/**
 * 释放锁的方法
 */
public  void unLock()&#123;
    //就是直接删除节点
    zkClient.delete(lockPath);
    System.out.println(&quot;释放了分布式锁,节点[&quot; + lockPath + &quot;]&quot;);
&#125;

@Override
public void handleDataChange(String s, Object o) throws Exception &#123;

&#125;

@Override
public void handleDataDeleted(String s) throws Exception &#123;
    synchronized (readNodesSets)&#123;
        if (!readNodesSets.contains(s))&#123;
            latch.countDown();
            readNodesSets.add(s);

        &#125;
    &#125;


&#125;

public static void main(String[] args) &#123;
    //模拟10个进程区抢分布式读锁  ,7个读进程、3个写进程
    CountDownLatch latch = new CountDownLatch(10);
    for (int i = 0;i&lt;7;i++)&#123;
        Thread thread = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    //先阻塞住，等所有进程准备好就一个唤醒
                    latch.await();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                //创建一个分布式锁对象。用于争取分布式锁
                DistributedReadLock distributedReadLock = new DistributedReadLock(true);
                //争取锁，如果获取到了，就直接执行下面的逻辑，获取不到就阻塞住，等待锁的释放。
                distributedReadLock.lock();
                //对共享资源的操作
                System.out.println(&quot;读进程&quot; + Thread.currentThread().getName() + &quot;读到的count = &quot; + count);
                //操作完就释放锁
                distributedReadLock.unLock();

            &#125;
        &#125;);
        //启动
        thread.start();
        latch.countDown();
    &#125;
    for (int i = 0;i&lt;3;i++)&#123;
        Thread thread = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    //先阻塞住，等所有进程准备好就一个唤醒
                    latch.await();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                //创建一个分布式锁对象。用于争取分布式锁
                DistributedReadLock distributedReadLock = new DistributedReadLock(false);
                //争取锁，如果获取到了，就直接执行下面的逻辑，获取不到就阻塞住，等待锁的释放。
                distributedReadLock.lock();
                //对共享资源的操作
                System.out.println(Thread.currentThread().getName() + &quot;执行写操作&quot;);
                count ++ ;
                //操作完就释放锁
                distributedReadLock.unLock();

            &#125;
        &#125;);
        //启动
        thread.start();
        latch.countDown();
    &#125;

    try &#123;
        //主进程睡眠50秒，等待count的最终值
        TimeUnit.SECONDS.sleep(30);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    System.out.println(&quot;count=&quot; + count);
&#125;
</code></pre>
<p>}</p>
<p><img src="https://img-blog.csdnimg.cn/20200706175038752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODM3MzEw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>由结果可知：<br>锁的顺序是<br>r-0 、r-1 、w-2 、r-3 、r-4 、w-5 、r-6 、r-7 、r-8 、w-9<br>所以获取锁的顺序是</p>
<p>r-0和r-1能同时获取锁。<br>等r-0和r-1都释放了锁，w-2就获取锁。<br>等w-2释放了锁 r-3和r-4就能同时获取锁。<br>等 r-3和r-4都释放了锁，w-5就能获取锁。<br>等w-5释放了锁，r-6 、r-7 、r-8 就能同时获得锁。<br>等r-6 、r-7 、r-8 都释放了锁，w-9就能获得锁。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="dubbo-超时设置过长"><a href="#dubbo-超时设置过长" class="headerlink" title="dubbo 超时设置过长"></a>dubbo 超时设置过长</h3><p>dubbo 接口超时时间设置过长 内部采用轮询机制  消息生产者其中一台服务老是定时重启 导致接口阻塞 导致服务宕机</p>
<p>解决方法 超时时间设短</p>
<h3 id="truncate问题"><a href="#truncate问题" class="headerlink" title="truncate问题"></a>truncate问题</h3><p>其反应truncate表时 别的所有业务都阻塞</p>
<p>解决方式是，测试用的表和线上的库隔离，或者升级mysql到8.0</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/25/Mysql%E4%BC%98%E5%8C%96%E4%B9%8B%E7%B2%BE%E9%AB%93/" rel="prev" title="Mysql优化之精髓">
                  <i class="fa fa-chevron-left"></i> Mysql优化之精髓
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vivid</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
